//------------------------------------------------
//--- 010 Editor v15.0 Binary Template
//
//      File: SC2.bt
//   Authors: Vorono4ka
//   Version: 0.9
//   Purpose: SC2 file format template (Supercell)
//  Category: Misc
// File Mask: *.sc, *.sc2
//  ID Bytes: 
//   History: 
//   0.9   2024-11-02 Vorono4ka: Matrix banks parsing fixed (seeking next pointer after parsing element)
//   0.8   2024-11-02 Vorono4ka: Parsing shape points as a structure
//   0.7   2024-11-02 Vorono4ka: Parsing matrix banks
//   0.6   2024-11-02 Vorono4ka: Parsing movie clips
//   0.5   2024-11-02 Vorono4ka: Parsing shapes and shape commands
//   0.4   2024-11-01 Vorono4ka: Parsing rectangles from headers
//   0.3   2024-11-01 Vorono4ka: String parsing from headers
//   0.2   2024-11-01 Vorono4ka: Reading movie clip modifiers
//   0.1   2024-11-01 Vorono4ka: Work on SC2 started... Reading textures section
//------------------------------------------------

typedef struct {
    local uint startPosition = FTell();
    
    local int32 offset = ReadInt(startPosition);
    local uint nextPosition = FTell();
    local uint position = startPosition + offset;
} Indirect<read=IndirectRead>;

string IndirectRead(Indirect &v) {
    local string s;
    SPrintf(s, "Position: %d", v.position);
    return s;
};

typedef struct {
    local uint position = FTell();
    int vtableOffset;
    local uint vtable = position - vtableOffset;
    FSeek(vtable);
    uint16 vtableSize;  // starting from here
    uint16 tableDataSize;
    local uint16 fieldCount = (vtableSize - 4) / 2;
    uint16 fieldOffsets[fieldCount];
} VTable <read=VTableValueRead, bgcolor = 0xFFFFFF, size=4>;

string VTableValueRead(VTable &v) {
    local string s;
    SPrintf(s, "Field offset count: %d", v.fieldCount);
    return s;
};

typedef struct {
    Indirect descriptor;
    
    FSeek(descriptor.position);
    VTable vtable;
    FSeek(descriptor.position);
} RootTable <bgcolor = 0xFFFF7F>;

int GoToField(uint rootTablePosition, VTable& vtable, uint fieldIndex) {
    if (fieldIndex < 0 || fieldIndex >= vtable.fieldCount) {
        return false;
    }
    
    local int16 fieldOffset = vtable.fieldOffsets[fieldIndex];
    Printf("fieldIndex: %d, fieldOffset: %d\n", fieldIndex, fieldOffset);
    if (fieldOffset == 0) {
        return false;
    }
    
    FSeek(rootTablePosition + fieldOffset);
    return true;
};

typedef struct (uint rootTablePosition, VTable& vtable, uint fieldIndex) {
    local int isPresent = GoToField(rootTablePosition, vtable, fieldIndex);
    if (!isPresent) {
        local uint nextPosition = FTell();
        local uint structOffset = 0;
        return;
    }
    
    local uint position = FTell();
    uint structOffset;
    local uint nextPosition = FTell();
    local uint structPosition = position + structOffset;
    FSeek(structPosition);
} StructBase <read=StructBaseRead>;

string StructBaseRead(StructBase &v) {
    if (!v.isPresent) {
        return "Value is not present";
    }
    
    local string s = "";
    SPrintf(s, "Position: %d", v.structPosition);
    return s;
};

typedef struct (RootTable& rootTable, uint fieldIndex) {
    StructBase base(rootTable.descriptor.position, rootTable.vtable, fieldIndex);
    
    uint32 count;
    // strT array[count];
    FSeek(base.nextPosition);
} Vector <read=VectorRead, bgcolor = 0xFFFFFF>;

string VectorRead(Vector &v) {
    if (!v.base.isPresent) {
        return StructBaseRead(v.base);
    }
    
    local string s = "";
    SPrintf(s, "Element count: %d", v.count);
    return s;
};

// Built-in types

typedef struct (uint rootTablePosition, VTable& vtable, uint fieldIndex) {
    StructBase base(rootTablePosition, vtable, fieldIndex);
    if (!base.isPresent) return;
    
    uint32 count;
    byte array[count];
    FSeek(base.nextPosition);
} Int8Vector;

typedef struct (uint rootTablePosition, VTable& vtable, uint fieldIndex) {
    StructBase base(rootTablePosition, vtable, fieldIndex);
    if (!base.isPresent) return;
    
    uint32 count;
    int16 array[count];
    FSeek(base.nextPosition);
} Int16Vector;

typedef struct (uint rootTablePosition, VTable& vtable, uint fieldIndex) {
    StructBase base(rootTablePosition, vtable, fieldIndex);
    if (!base.isPresent) return;
    
    uint32 count;
    int32 array[count];
    FSeek(base.nextPosition);
} Int32Vector;

typedef struct (uint rootTablePosition, VTable& vtable, uint fieldIndex) {
    StructBase base(rootTablePosition, vtable, fieldIndex);
    if (!base.isPresent) return;
    
    uint32 count;
    float array[count];
    FSeek(base.nextPosition);
} FloatVector;

typedef struct (uint rootTablePosition, VTable& vtable, uint fieldIndex) {
    local uint position = FTell();
    local byte isPresent = GoToField(rootTablePosition, vtable, fieldIndex);
    if (isPresent) {
        byte value;
        FSeek(position);
    } else {
        local string value = "Value is not present";
    }
} Int8 <read=value>;

typedef struct (uint rootTablePosition, VTable& vtable, uint fieldIndex) {
    local uint position = FTell();
    local byte isPresent = GoToField(rootTablePosition, vtable, fieldIndex);
    if (isPresent) {
        ubyte value;
        FSeek(position);
    } else {
        local string value = "Value is not present";
    }
} UInt8 <read=value>;

typedef struct (uint rootTablePosition, VTable& vtable, uint fieldIndex) {
    local uint position = FTell();
    local byte isPresent = GoToField(rootTablePosition, vtable, fieldIndex);
    if (isPresent) {
        int16 value;
        FSeek(position);
    } else {
        local int16 value = 0; // "Value is not present";
    }
} Int16 <read=value>;

typedef struct (uint rootTablePosition, VTable& vtable, uint fieldIndex) {
    local uint position = FTell();
    local byte isPresent = GoToField(rootTablePosition, vtable, fieldIndex);
    if (isPresent) {
        uint16 value;
        FSeek(position);
    } else {
        local uint16 value = 0; // "Value is not present";
    }
} UInt16 <read=value>;

typedef struct (uint rootTablePosition, VTable& vtable, uint fieldIndex) {
    local uint position = FTell();
    local byte isPresent = GoToField(rootTablePosition, vtable, fieldIndex);
    if (isPresent) {
        int32 value;
        FSeek(position);
    } else {
        local string value = "Value is not present";
    }
} Int32 <read=value>;

typedef struct (uint rootTablePosition, VTable& vtable, uint fieldIndex) {
    local uint position = FTell();
    local byte isPresent = GoToField(rootTablePosition, vtable, fieldIndex);
    if (isPresent) {
        uint32 value;
        FSeek(position);
    } else {
        local string value = "Value is not present";
    }
} UInt32 <read=value>;

typedef struct (uint rootTablePosition, VTable& vtable, uint fieldIndex) {
    local uint position = FTell();
    local byte isPresent = GoToField(rootTablePosition, vtable, fieldIndex);
    if (isPresent) {
        float value;
        FSeek(position);
    } else {
        local string value = "Value is not present";
    }
} Float <read=value>;

typedef struct (uint rootTablePosition, VTable& vtable, uint fieldIndex) {
    StructBase base(rootTablePosition, vtable, fieldIndex);
    
    uint32 length;
    char array[length];
    FSeek(base.nextPosition);
} ByteArray<read=ByteArrayRead>;

string ByteArrayRead(ByteArray& v) {
    string s;
    SPrintf(s, "Byte Array [%d]", v.length);
    return s;
}

// 

typedef struct {
    ushort childIndex;
    ushort matrixIndex;
    ushort colorTransformIndex;
} MovieClipFrameElement <read=frameElementRead, size=(3*sizeof(ushort))>;

string frameElementRead(MovieClipFrameElement &v) {
    local string s;
    SPrintf(s, "%d - %d, %d", v.childIndex, v.matrixIndex, v.colorTransformIndex);
    return s;
};

typedef struct (RootTable& rootTable, uint fieldIndex) {
    StructBase base(rootTable.descriptor.position, rootTable.vtable, fieldIndex);
    
    uint32 count;
    MovieClipFrameElement array[count / 3];
    FSeek(base.nextPosition);
} MovieClipFrameElementVector;

typedef struct {
    Indirect descriptor;
    
    FSeek(descriptor.position);
    
    uint32 length;
    char text[length];
    
    FSeek(descriptor.nextPosition);
} String<read=StringRead, size=(sizeof(uint32))>;  // only size of descriptor offset

string StringRead(String& v) {
    if (v.length == 0) {
        return "";
    }
    
    return v.text;
}

typedef struct (RootTable& rootTable, uint fieldIndex) {
    StructBase base(rootTable.descriptor.position, rootTable.vtable, fieldIndex);
    
    uint32 count;
    String array[count] <optimize=false>;
    FSeek(base.nextPosition);
} StringVector <read=StringVectorRead>;

string StringVectorRead(StringVector& v) {
    local string s; 
    SPrintf(s, "Count: %d", v.count); 
    return s;
}

typedef struct {
    float left, top, right, bottom;
} Rect<read=RectRead, size=(sizeof(float)*4)>;

string RectRead(Rect& v) {
    local string s;
    SPrintf(s, "%.2f, %.2f, %.2f, %.2f", v.left, v.top, v.right, v.bottom);
    return s;
};

typedef struct (RootTable& rootTable, uint fieldIndex) {
    StructBase base(rootTable.descriptor.position, rootTable.vtable, fieldIndex);
    
    uint32 count;
    Rect array[count];
    FSeek(base.nextPosition);
} RectVector;

// Matrices and color transformations

typedef struct {
    float a, b, c, d, x, y;
} Matrix2x3 <read=Matrix2x3Read, size=(6*sizeof(float))>;

string Matrix2x3Read(Matrix2x3& v) {
    local string s;
    SPrintf(s, "%.2f %.2f %.2f %.2f %.2f %.2f", ReadFloat(startof(v)), ReadFloat(startof(v)+sizeof(float)), ReadFloat(startof(v)+sizeof(float)*2), ReadFloat(startof(v)+sizeof(float)*3), ReadFloat(startof(v)+sizeof(float)*4), ReadFloat(startof(v)+sizeof(float)*5));
    return s;
};

typedef struct (uint rootTablePosition, VTable& vtable, uint fieldIndex) {
    StructBase base(rootTablePosition, vtable, fieldIndex);
    
    uint32 count;
    Matrix2x3 array[count];
    FSeek(base.nextPosition);
} Matrix2x3Vector;

typedef struct {
    ubyte redAddition;
    ubyte greenAddition;
    ubyte blueAddition;

    ubyte alpha;

    ubyte redMultiplier;
    ubyte greenMultiplier;
    ubyte blueMultiplier;
} ColorTransform <read=ColorTransformRead, size=(7*sizeof(ubyte))>;

string ColorTransformRead(ColorTransform& v) {
    local string s;
    local ubyte ra = ReadUByte(startof(v)+sizeof(ubyte));
    local ubyte ga = ReadUByte(startof(v)+sizeof(ubyte)*1);
    local ubyte ba = ReadUByte(startof(v)+sizeof(ubyte)*2);
    local ubyte a = ReadUByte(startof(v)+sizeof(ubyte)*3);
    local ubyte r = ReadUByte(startof(v)+sizeof(ubyte)*4);
    local ubyte g = ReadUByte(startof(v)+sizeof(ubyte)*5);
    local ubyte b = ReadUByte(startof(v)+sizeof(ubyte)*6);
    SPrintf(s, "RGBA: #%02x%02x%02x%02x", (r + ra) * a, (g + ga) * a, (b + ba) * a, a);
    return s;
};

typedef struct (uint rootTablePosition, VTable& vtable, uint fieldIndex) {
    StructBase base(rootTablePosition, vtable, fieldIndex);
    
    uint32 count;
    ColorTransform array[count];
    FSeek(base.nextPosition);
} ColorTransformVector;

typedef struct {
    RootTable rootTable;
    
    Matrix2x3Vector matrices(rootTable.descriptor.position, rootTable.vtable, 0);
    ColorTransformVector colorTransforms(rootTable.descriptor.position, rootTable.vtable, 1);
    FSeek(rootTable.descriptor.nextPosition + 4);
} MatrixBank<read=MatrixBankRead>;

string MatrixBankRead(MatrixBank& v) {
    local string s;
    SPrintf(s, "Matrix bank (M: %d, C: %d)", v.matrices.count, v.colorTransforms.count);
    return s;
};

typedef struct (RootTable& rootTable, uint fieldIndex) {
    StructBase base(rootTable.descriptor.position, rootTable.vtable, fieldIndex);
    
    uint32 count;
    MatrixBank array[count] <optimize=false>;
    FSeek(base.nextPosition);
} MatrixBankVector;

// Movie Clips

typedef struct {
    float x, y;
    ushort u, v;
} ShapePoint<read=ShapePointRead, size=(sizeof(float)*2+sizeof(ushort)*2)>;

string ShapePointRead(ShapePoint& v) {
    string s;
    SPrintf(s, "%.2f, %.2f (%d, %d)", ReadFloat(startof(v)), ReadFloat(startof(v)+sizeof(float)), ReadUShort(startof(v)+sizeof(float)*2), ReadUShort(startof(v)+sizeof(float)*2+sizeof(ushort)));
    return s;
}

typedef struct (uint rootTablePosition, VTable& vtable, uint fieldIndex) {
    StructBase base(rootTablePosition, vtable, fieldIndex);
    
    uint32 count;
    ShapePoint array[count / sizeof(ShapePoint)];
    FSeek(base.nextPosition);
} ShapePointVector;

typedef struct {
    RootTable rootTable;
    
    StringVector strings(rootTable, 0);
    Vector unk2(rootTable, 1);
    Vector unk3(rootTable, 2);
    RectVector scalingGrids(rootTable, 3);
    MovieClipFrameElementVector movieClipFrameElements(rootTable, 4);
    ShapePointVector shapePoints(rootTable.descriptor.position, rootTable.vtable, 5);
    MatrixBankVector matrixBanks(rootTable, 6);
} HeaderRoot;

typedef struct {
    RootTable rootTable;
    
    Int16Vector exportIds(rootTable.descriptor.position, rootTable.vtable, 0);
    Int32Vector exportNameIds(rootTable.descriptor.position, rootTable.vtable, 1);
} ExportNamesRoot <bgcolor=0xFF0000>;

typedef struct {
    RootTable rootTable;
} TextFieldsRoot <bgcolor=0x0000FF>;

typedef struct {
    uint unk1; // always 0
    uint textureIndex;
    uint pointCount;
    uint startingPointIndex;
} ShapeDrawBitmapCommand<read=ShapeDrawBitmapCommandRead>;

string ShapeDrawBitmapCommandRead(ShapeDrawBitmapCommand& v) {
    local string s;
    SPrintf(s, "CMD (TX: %d): %d+%d", v.textureIndex, v.startingPointIndex, v.pointCount);
    return s;
}

typedef struct (uint rootTablePosition, VTable& vtable, uint fieldIndex) {
    StructBase base(rootTablePosition, vtable, fieldIndex);
    
    int32 count;
    ShapeDrawBitmapCommand array[count];
    FSeek(base.nextPosition);
} ShapeDrawBitmapCommandVector;

typedef struct {
    Indirect descriptor;
    
    FSeek(descriptor.position);
    VTable vtable;
    
    UInt16 id(descriptor.position, vtable, 0);
    ShapeDrawBitmapCommandVector commands(descriptor.position, vtable, 1);
    
    FSeek(descriptor.nextPosition);
} Shape<read=ShapeRead, size=4>;

string ShapeRead(Shape& v) {
    string s;
    SPrintf(s, "Shape #%d (%d commands)", v.id.value, v.commands.count);
    return s;
}

typedef struct (RootTable& rootTable, uint fieldIndex) {
    StructBase base(rootTable.descriptor.position, rootTable.vtable, fieldIndex);
    
    uint32 count;
    Shape array[count] <optimize=false>;
    FSeek(base.nextPosition);
} ShapeVector;

typedef struct {
    RootTable rootTable;
    
    ShapeVector shapes(rootTable, 0);
} ShapesRoot <bgcolor=0x00FF00>;

// Modifiers

typedef struct {
    ushort id;
    ushort type;
} MovieClipModifier<read=MovieClipModifierRead>;

string MovieClipModifierRead(MovieClipModifier& v) {
    string s;
    SPrintf(s, "Modifier (%d) #%d", v.type, v.id);
    return s;
}

typedef struct (RootTable& rootTable, uint fieldIndex) {
    StructBase base(rootTable.descriptor.position, rootTable.vtable, fieldIndex);
    
    uint32 count;
    MovieClipModifier array[count];
    FSeek(base.nextPosition);
} MovieClipModifierVector;

typedef struct {
    RootTable rootTable;
    
    MovieClipModifierVector modifiers(rootTable, 0);
} MovieClipModifiersRoot <bgcolor=0x00FF00>;

// Movie Clips

typedef struct {
    uint32 usedTransformsCount;
    uint32 labelStringIndex;
} MovieClipFrame<read=MovieClipFrameRead>;

string MovieClipFrameRead(MovieClipFrame& v) {
    string s;
    SPrintf(s, "Frame (SID: %d), %d", v.labelStringIndex, v.usedTransformsCount);
    return s;
}

typedef struct (uint rootTablePosition, VTable& vtable, uint fieldIndex) {
    StructBase base(rootTablePosition, vtable, fieldIndex);
    
    uint32 count;
    MovieClipFrame array[count];
    FSeek(base.nextPosition);
} MovieClipFrameVector;

typedef struct {
    Indirect descriptor;
    
    FSeek(descriptor.position);
    VTable vtable;
    
    UInt16 id(descriptor.position, vtable, 0);
    UInt32 exportName(descriptor.position, vtable, 1);  // export name, string reference index
    UInt8 fps(descriptor.position, vtable, 2);  // second byte of fps short. this.fps = this.fps & 0xFF80 | u2 & 0x7F
    UInt16 frameCount(descriptor.position, vtable, 3);
    UInt8 u4(descriptor.position, vtable, 4);  // 7th bit of fps short - some boolean. this.fps = (u4 << 7) | this.fps & 0xFF7F;
    Int16Vector childIds(descriptor.position, vtable, 5);
    Int8Vector childBlends(descriptor.position, vtable, 6);
    Int16Vector childNames(descriptor.position, vtable, 7);  // refers to the strings from header
    MovieClipFrameVector frames(descriptor.position, vtable, 8);
    UInt32 frameElementOffset(descriptor.position, vtable, 9);  // or start frame element index, TODO: determine whether it bytes or not
    UInt16 matrixBankIndex(descriptor.position, vtable, 10);  // first byte of fps short. this.fps = ((u10 & 0x7F) << 8) | this.fps & 0x80FF
    UInt32 scalingGridIndex(descriptor.position, vtable, 11);
    
    FSeek(descriptor.nextPosition);
} MovieClip<read=MovieClipRead, size=4>;

string MovieClipRead(MovieClip& v) {
    string s;
    SPrintf(s, "MovieClip #%d", v.id.value);
    return s;
}

typedef struct (RootTable& rootTable, uint fieldIndex) {
    StructBase base(rootTable.descriptor.position, rootTable.vtable, fieldIndex);
    
    uint32 count;
    MovieClip array[count] <optimize=false>;
    FSeek(base.nextPosition);
} MovieClipVector;

typedef struct {
    RootTable rootTable;
    
    MovieClipVector movieClips(rootTable, 0);
} MovieClipsRoot <bgcolor=0x00FF00>;

// Textures

typedef struct (RootTable& rootTable, uint fieldIndex) {    
    StructBase base(rootTable.descriptor.position, rootTable.vtable, fieldIndex);
    
    VTable vtable;
    
    Int32 flags(base.structPosition, vtable, 0);
    // Type converts to strange metrics: If in bounds, then [42, 43, 40, 70, 265, 70, 70, 42, 264](v - 2), otherwise 70.
    Int16 type(base.structPosition, vtable, 1);
    Int16 width(base.structPosition, vtable, 2);
    Int16 height(base.structPosition, vtable, 3);
    ByteArray textureData(base.structPosition, vtable, 4);
    if (textureData.base.isPresent) {
        Int32 textureFilename(base.structPosition, vtable, 5);  // offset to null-terminated string or string reference
    }
    
    FSeek(base.nextPosition);
} Texture<read=TextureRead>;

string TextureRead(Texture& v) {
    string s;
    SPrintf(s, "Texture (%dx%d)", v.width.value, v.height.value);
    return s;
}

typedef struct {
    RootTable table;
    
    Texture lowresTexture(table, 0);
    Texture highresTexture(table, 1);
    FSeek(table.descriptor.nextPosition);
} TextureSet;

typedef struct (RootTable& rootTable, uint fieldIndex) {
    StructBase base(rootTable.descriptor.position, rootTable.vtable, fieldIndex);
    
    uint32 count;
    TextureSet array[count] <optimize=false>;
    FSeek(base.nextPosition);
} TextureSetVector;

typedef struct {
    RootTable rootTable;
    
    TextureSetVector textures(rootTable, 0);
} TexturesRoot <bgcolor=0x0000FF>;

// MAIN

struct DataChunk (uint i) {
    int length;
    local uint position = FTell();

    switch (i)
    {
        case 0:
            HeaderRoot header;
            break;
        case 1:
            ExportNamesRoot exports;
            break;
        case 2:
            TextFieldsRoot textFields;
            break;
        case 3:
            ShapesRoot shapes;
            break;
        case 4:
            MovieClipsRoot movieClips;
            break;
        case 5:
            MovieClipModifiersRoot modifiers;
            break;
        case 6:
            TexturesRoot textures;
            break;
        default:
            char data[length];
            break;
    }
    
    FSeek(position + length);
};

struct FILE {
    local uint i = 0;
    while (!FEof()) {
        DataChunk chunk(i++);
    }
} file;
